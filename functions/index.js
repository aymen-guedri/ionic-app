const functions = require('firebase-functions');\nconst admin = require('firebase-admin');\nconst { getMessaging } = require('firebase-admin/messaging');\n\nadmin.initializeApp();\n\nconst db = admin.firestore();\nconst messaging = getMessaging();\n\n// Send push notification when reservation is approved\nexports.onReservationApproved = functions.firestore\n  .document('reservations/{reservationId}')\n  .onUpdate(async (change, context) => {\n    const before = change.before.data();\n    const after = change.after.data();\n    \n    // Check if status changed to approved\n    if (before.status !== 'approved' && after.status === 'approved') {\n      try {\n        // Get user's FCM token\n        const userDoc = await db.collection('users').doc(after.userId).get();\n        const userData = userDoc.data();\n        \n        if (userData && userData.fcmToken) {\n          const message = {\n            token: userData.fcmToken,\n            notification: {\n              title: '✅ Reservation Approved',\n              body: `Your reservation for spot ${after.spotNumber} has been approved!`\n            },\n            data: {\n              type: 'reservation',\n              action: 'approved',\n              reservationId: context.params.reservationId,\n              spotNumber: after.spotNumber\n            }\n          };\n          \n          await messaging.send(message);\n          console.log('Notification sent for approved reservation:', context.params.reservationId);\n        }\n        \n        // Create notification record\n        await db.collection('notifications').add({\n          userId: after.userId,\n          title: 'Reservation Approved',\n          message: `Your reservation for spot ${after.spotNumber} has been approved!`,\n          type: 'reservation',\n          read: false,\n          data: {\n            reservationId: context.params.reservationId,\n            spotNumber: after.spotNumber\n          },\n          createdAt: admin.firestore.FieldValue.serverTimestamp()\n        });\n        \n      } catch (error) {\n        console.error('Error sending approval notification:', error);\n      }\n    }\n  });\n\n// Send reminder notifications\nexports.sendReservationReminders = functions.pubsub\n  .schedule('every 5 minutes')\n  .onRun(async (context) => {\n    try {\n      const now = admin.firestore.Timestamp.now();\n      const reminderTime = new admin.firestore.Timestamp(\n        now.seconds + (15 * 60), // 15 minutes from now\n        now.nanoseconds\n      );\n      \n      // Find reservations ending in 15 minutes\n      const reservationsSnapshot = await db.collection('reservations')\n        .where('status', '==', 'active')\n        .where('endTime', '<=', reminderTime)\n        .where('endTime', '>', now)\n        .get();\n      \n      const notifications = [];\n      \n      for (const doc of reservationsSnapshot.docs) {\n        const reservation = doc.data();\n        \n        // Check if reminder already sent\n        const existingReminder = await db.collection('notifications')\n          .where('userId', '==', reservation.userId)\n          .where('type', '==', 'reminder')\n          .where('data.reservationId', '==', doc.id)\n          .get();\n        \n        if (existingReminder.empty) {\n          // Get user's FCM token\n          const userDoc = await db.collection('users').doc(reservation.userId).get();\n          const userData = userDoc.data();\n          \n          if (userData && userData.fcmToken) {\n            const minutesLeft = Math.ceil((reservation.endTime.seconds - now.seconds) / 60);\n            \n            const message = {\n              token: userData.fcmToken,\n              notification: {\n                title: '⏰ Reservation Reminder',\n                body: `Your reservation for spot ${reservation.spotNumber} expires in ${minutesLeft} minutes`\n              },\n              data: {\n                type: 'reminder',\n                reservationId: doc.id,\n                spotNumber: reservation.spotNumber,\n                minutesLeft: minutesLeft.toString()\n              }\n            };\n            \n            notifications.push(messaging.send(message));\n            \n            // Create notification record\n            await db.collection('notifications').add({\n              userId: reservation.userId,\n              title: 'Reservation Reminder',\n              message: `Your reservation for spot ${reservation.spotNumber} expires in ${minutesLeft} minutes`,\n              type: 'reminder',\n              read: false,\n              data: {\n                reservationId: doc.id,\n                spotNumber: reservation.spotNumber,\n                minutesLeft\n              },\n              createdAt: admin.firestore.FieldValue.serverTimestamp()\n            });\n          }\n        }\n      }\n      \n      if (notifications.length > 0) {\n        await Promise.all(notifications);\n        console.log(`Sent ${notifications.length} reminder notifications`);\n      }\n      \n    } catch (error) {\n      console.error('Error sending reminder notifications:', error);\n    }\n  });\n\n// Auto-expire reservations\nexports.autoExpireReservations = functions.pubsub\n  .schedule('every 5 minutes')\n  .onRun(async (context) => {\n    try {\n      const now = admin.firestore.Timestamp.now();\n      \n      // Find expired reservations\n      const expiredReservations = await db.collection('reservations')\n        .where('status', 'in', ['approved', 'active'])\n        .where('endTime', '<=', now)\n        .get();\n      \n      const batch = db.batch();\n      \n      for (const doc of expiredReservations.docs) {\n        const reservation = doc.data();\n        \n        // Update reservation status\n        batch.update(doc.ref, {\n          status: 'expired',\n          expiredAt: admin.firestore.FieldValue.serverTimestamp()\n        });\n        \n        // Free up the parking spot\n        const spotRef = db.collection('parkingSpots').doc(reservation.spotId);\n        batch.update(spotRef, {\n          status: 'available',\n          updatedAt: admin.firestore.FieldValue.serverTimestamp()\n        });\n        \n        // Create notification\n        const notificationRef = db.collection('notifications').doc();\n        batch.set(notificationRef, {\n          userId: reservation.userId,\n          title: 'Reservation Expired',\n          message: `Your reservation for spot ${reservation.spotNumber} has expired`,\n          type: 'reservation',\n          read: false,\n          data: {\n            reservationId: doc.id,\n            spotNumber: reservation.spotNumber\n          },\n          createdAt: admin.firestore.FieldValue.serverTimestamp()\n        });\n      }\n      \n      if (!expiredReservations.empty) {\n        await batch.commit();\n        console.log(`Expired ${expiredReservations.size} reservations`);\n      }\n      \n    } catch (error) {\n      console.error('Error expiring reservations:', error);\n    }\n  });\n\n// Update user loyalty points\nexports.updateLoyaltyPoints = functions.firestore\n  .document('reservations/{reservationId}')\n  .onUpdate(async (change, context) => {\n    const before = change.before.data();\n    const after = change.after.data();\n    \n    // Award points when reservation is completed\n    if (before.status !== 'completed' && after.status === 'completed') {\n      try {\n        const userRef = db.collection('users').doc(after.userId);\n        const userDoc = await userRef.get();\n        const userData = userDoc.data();\n        \n        if (userData) {\n          // Award 10 points per hour\n          const pointsEarned = Math.ceil(after.duration * 10);\n          const newPoints = (userData.loyaltyPoints || 0) + pointsEarned;\n          \n          // Update user points\n          await userRef.update({\n            loyaltyPoints: newPoints,\n            updatedAt: admin.firestore.FieldValue.serverTimestamp()\n          });\n          \n          // Check for tier upgrade\n          let newTier = userData.tier || 'bronze';\n          if (newPoints >= 1000 && newTier !== 'platinum') {\n            newTier = 'platinum';\n          } else if (newPoints >= 500 && newTier === 'bronze') {\n            newTier = 'gold';\n          } else if (newPoints >= 200 && newTier === 'bronze') {\n            newTier = 'silver';\n          }\n          \n          if (newTier !== userData.tier) {\n            await userRef.update({ tier: newTier });\n            \n            // Send tier upgrade notification\n            await db.collection('notifications').add({\n              userId: after.userId,\n              title: 'Tier Upgrade!',\n              message: `Congratulations! You've been upgraded to ${newTier} tier!`,\n              type: 'promotion',\n              read: false,\n              data: {\n                newTier,\n                pointsEarned,\n                totalPoints: newPoints\n              },\n              createdAt: admin.firestore.FieldValue.serverTimestamp()\n            });\n          }\n          \n          console.log(`Awarded ${pointsEarned} points to user ${after.userId}`);\n        }\n      } catch (error) {\n        console.error('Error updating loyalty points:', error);\n      }\n    }\n  });\n\n// Generate daily analytics\nexports.generateDailyAnalytics = functions.pubsub\n  .schedule('0 1 * * *') // Run at 1 AM daily\n  .timeZone('Africa/Tunis')\n  .onRun(async (context) => {\n    try {\n      const yesterday = new Date();\n      yesterday.setDate(yesterday.getDate() - 1);\n      yesterday.setHours(0, 0, 0, 0);\n      \n      const today = new Date(yesterday);\n      today.setDate(today.getDate() + 1);\n      \n      const startTimestamp = admin.firestore.Timestamp.fromDate(yesterday);\n      const endTimestamp = admin.firestore.Timestamp.fromDate(today);\n      \n      // Get reservations for yesterday\n      const reservationsSnapshot = await db.collection('reservations')\n        .where('createdAt', '>=', startTimestamp)\n        .where('createdAt', '<', endTimestamp)\n        .get();\n      \n      const reservations = reservationsSnapshot.docs.map(doc => doc.data());\n      \n      // Calculate analytics\n      const analytics = {\n        date: admin.firestore.Timestamp.fromDate(yesterday),\n        totalReservations: reservations.length,\n        approvedReservations: reservations.filter(r => r.status === 'approved' || r.status === 'completed').length,\n        completedReservations: reservations.filter(r => r.status === 'completed').length,\n        cancelledReservations: reservations.filter(r => r.status === 'cancelled').length,\n        totalRevenue: reservations\n          .filter(r => r.status === 'completed')\n          .reduce((sum, r) => sum + (r.totalCost || 0), 0),\n        averageDuration: reservations.length > 0 \n          ? reservations.reduce((sum, r) => sum + (r.duration || 0), 0) / reservations.length \n          : 0,\n        createdAt: admin.firestore.FieldValue.serverTimestamp()\n      };\n      \n      // Save analytics\n      await db.collection('analytics').add(analytics);\n      \n      console.log('Daily analytics generated:', analytics);\n      \n    } catch (error) {\n      console.error('Error generating daily analytics:', error);\n    }\n  });\n\n// HTTP function to send custom notifications\nexports.sendNotification = functions.https.onCall(async (data, context) => {\n  // Check if user is authenticated and is admin\n  if (!context.auth || !context.auth.token.admin) {\n    throw new functions.https.HttpsError(\n      'permission-denied',\n      'Only admins can send notifications'\n    );\n  }\n  \n  try {\n    const { userIds, notification } = data;\n    \n    if (!Array.isArray(userIds) || userIds.length === 0) {\n      throw new functions.https.HttpsError(\n        'invalid-argument',\n        'User IDs array is required'\n      );\n    }\n    \n    const notifications = [];\n    const notificationRecords = [];\n    \n    for (const userId of userIds) {\n      // Get user's FCM token\n      const userDoc = await db.collection('users').doc(userId).get();\n      const userData = userDoc.data();\n      \n      if (userData && userData.fcmToken) {\n        const message = {\n          token: userData.fcmToken,\n          notification: {\n            title: notification.title,\n            body: notification.body\n          },\n          data: notification.data || {}\n        };\n        \n        notifications.push(messaging.send(message));\n      }\n      \n      // Create notification record\n      notificationRecords.push({\n        userId,\n        title: notification.title,\n        message: notification.body,\n        type: notification.type || 'general',\n        read: false,\n        data: notification.data || {},\n        createdAt: admin.firestore.FieldValue.serverTimestamp()\n      });\n    }\n    \n    // Send all notifications\n    await Promise.all(notifications);\n    \n    // Save notification records\n    const batch = db.batch();\n    notificationRecords.forEach(record => {\n      const ref = db.collection('notifications').doc();\n      batch.set(ref, record);\n    });\n    await batch.commit();\n    \n    return { success: true, sent: notifications.length };\n    \n  } catch (error) {\n    console.error('Error sending notifications:', error);\n    throw new functions.https.HttpsError(\n      'internal',\n      'Failed to send notifications'\n    );\n  }\n});